# Code Documentation üìÑ

## Code
```cpp
#include <iostream>
#include <typeinfo>
using namespace std;

class B {
    int i; // Private data member

public:
    B(int x) { i = x + 1; } // Constructor
    int get_i() { return i; } // Public method to access private data member
};

class D : public B { // Inheritance: D inherits from B
    int j; // Private data member

public:
    D() : B(1) { // Constructor calling base class constructor
        j = i + 2; // Error: Attempting to access private member 'i' of class B
    }
    int get_j() { return j; } // Public method to access private data member
};

int main() {
    B* p = new D[10]; // Dynamic array of D objects, but stored as B pointers
    cout << p->get_i(); // Accessing get_i() through base class pointer
    if (typeid((B*)p).name() == "D*") // Run-Time Type Information (RTTI) üßê
        cout << ((D*)p)->get_j(); // Attempting to access get_j() through cast
    return 0;
}
```

## Output
```
Compilation Error:
C:\Users\drago\Downloads\mihainsto FMI master Year%201%20Sem%202-pooExamQuestions_probleme\Year 1 Sem 2\pooExamQuestions\probleme\22.cpp: In constructor 'D::D()':
C:\Users\drago\Downloads\mihainsto FMI master Year%201%20Sem%202-pooExamQuestions_probleme\Year 1 Sem 2\pooExamQuestions\probleme\22.cpp:18:13: error: 'int B::i' is private within this context
         j = i + 2;
             ^
C:\Users\drago\Downloads\mihainsto FMI master Year%201%20Sem%202-pooExamQuestions_probleme\Year 1 Sem 2\pooExamQuestions\probleme\22.cpp:5:9: note: declared private here
     int i;
         ^
```

## Concepts Used üß†

### 1. [[Class and Object concepts]]
- The code defines two classes, `B` and `D`, which are blueprints for creating objects.
- `B` has a private data member `i` and a public method `get_i()`.
- `D` inherits from `B` and has its own private data member `j` and a public method `get_j()`.

### 2. [[Encapsulation]]
- The data member `i` in class `B` is private, meaning it cannot be accessed directly from outside the class or even from derived classes.
- This is why the line `j = i + 2;` in the constructor of `D` causes a compilation error. üö´

### 3. [[Inheritance]]
- Class `D` inherits from class `B`. This means `D` has access to the public and protected members of `B`.
- However, private members of `B` (like `i`) are not accessible in `D`.

### 4. [[Constructors]]
- `B` has a constructor that initializes `i` based on the input parameter `x`.
- `D` has a constructor that calls `B`'s constructor with the argument `1` and attempts to initialize `j` using `i`.

### 5. [[Run-Time Type Information (RTTI) in C++ üßê]]
- The code uses `typeid` to check the type of the object pointed to by `p`.
- However, the check `if (typeid((B*)p).name() == "D*")` is problematic because `typeid` on a pointer will return the type of the pointer (`B*`), not the actual object type (`D*`).

### 6. [[Memory Management]]
- The line `B* p = new D[10];` dynamically allocates an array of 10 `D` objects, but stores them as `B` pointers.
- This can lead to issues when trying to access derived class members through base class pointers.

## Issues and Fixes üõ†Ô∏è

### Issue 1: Accessing Private Member `i` in Derived Class
- The line `j = i + 2;` in the constructor of `D` tries to access the private member `i` of `B`, which is not allowed.
- **Fix**: Use a public or protected method to access `i`. For example, modify `B` to have a protected method `get_i_protected()`.

```cpp
class B {
    int i;

protected:
    int get_i_protected() { return i; }

public:
    B(int x) { i = x + 1; }
    int get_i() { return i; }
};

class D : public B {
    int j;

public:
    D() : B(1) {
        j = get_i_protected() + 2; // Now this works!
    }
    int get_j() { return j; }
};
```

### Issue 2: Incorrect Use of RTTI
- The check `if (typeid((B*)p).name() == "D*")` is incorrect because `typeid` on a pointer will return the type of the pointer, not the object.
- **Fix**: Use `dynamic_cast` to safely downcast the pointer.

```cpp
if (D* d = dynamic_cast<D*>(p)) {
    cout << d->get_j();
}
```

### Issue 3: Memory Management with Arrays
- The line `B* p = new D[10];` is problematic because it creates an array of `D` objects but stores them as `B` pointers.
- **Fix**: Use a container like `std::vector` to manage the array of objects.

```cpp
std::vector<D*> p;
for (int i = 0; i < 10; ++i) {
    p.push_back(new D());
}
cout << p[0]->get_i();
if (D* d = dynamic_cast<D*>(p[0])) {
    cout << d->get_j();
}
```

## Simpler Example to Illustrate [[Inheritance]] and [[Encapsulation]]

```cpp
class Animal {
    int age; // Private data member

protected:
    int getAge() { return age; } // Protected method

public:
    Animal(int a) : age(a) {}
    void speak() { cout << "Animal sound!" << endl; }
};

class Dog : public Animal {
public:
    Dog(int a) : Animal(a) {}
    void bark() {
        cout << "Woof! I am " << getAge() << " years old." << endl;
    }
};

int main() {
    Dog myDog(5);
    myDog.bark(); // Output: Woof! I am 5 years old.
    return 0;
}
```

In this example:
- `Dog` inherits from `Animal`.
- `age` is private in `Animal`, so `Dog` cannot access it directly. Instead, it uses the protected method `getAge()`.

## Conclusion üéØ
This code demonstrates several key [[Object-Oriented Programming]] concepts but also contains some common pitfalls. By understanding [[Encapsulation]], [[Inheritance]], and [[Run-Time Type Information (RTTI) in C++ üßê]], you can write more robust and maintainable C++ code. üöÄ