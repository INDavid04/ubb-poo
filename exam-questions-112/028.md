# Code Documentation

## Code
```cpp
#include <iostream>
using namespace std;

class problema {
    int i;

public:
    problema(int j = 5) { i = j; }
    void schimba() { i++; }
    void afiseaza() { cout << "starea curenta " << i << "\n"; }
};
problema mister1() { return problema(6); }
void mister2(problema& o)
{
    o.afiseaza();
    o.schimba();
    o.afiseaza();
}
int main()
{
    mister2(mister1()); //(1)
    return 0;
}
```

## Output
```
Compilation Error:
C:\Users\drago\Downloads\mihainsto FMI master Year%201%20Sem%202-pooExamQuestions_probleme\Year 1 Sem 2\pooExamQuestions\probleme\28.cpp: In function 'int main()':
C:\Users\drago\Downloads\mihainsto FMI master Year%201%20Sem%202-pooExamQuestions_probleme\Year 1 Sem 2\pooExamQuestions\probleme\28.cpp:21:20: error: invalid initialization of non-const reference of type 'problema&' from an rvalue of type 'problema'
     mister2(mister1()); //(1)
             ~~~~~~~^~
C:\Users\drago\Downloads\mihainsto FMI master Year%201%20Sem%202-pooExamQuestions_probleme\Year 1 Sem 2\pooExamQuestions\probleme\28.cpp:13:6: note:   initializing argument 1 of 'void mister2(problema&)'
 void mister2(problema& o)
      ^~~~~~~
```

## Explanation

### Concepts Used

1. **[[Class and Object concepts]]** 🧐
   - The code defines a class `problema` which encapsulates data and methods.
   - An object of this class is created and manipulated in the `main` function.

2. **[[Encapsulation]]** 🛡️
   - The class `problema` encapsulates the data member `i` and provides public methods to interact with it (`schimba` and `afiseaza`).

3. **[[Constructors]]** 🏗️
   - The class `problema` has a constructor that initializes the data member `i` with a default value of 5 or a provided value.

4. **[[Const-correctness & code clarity]]** 🔒
   - The error in the code is related to const-correctness. The function `mister2` expects a non-const reference to an object of type `problema`, but `mister1()` returns a temporary object (an rvalue), which cannot be bound to a non-const reference.

### Detailed Explanation

The code defines a class `problema` with a private data member `i` and public methods to modify and display its value. The class has a constructor that initializes `i` with a default value of 5 or a provided value.

The function `mister1` returns a temporary object of type `problema` initialized with the value 6. The function `mister2` takes a non-const reference to a `problema` object, displays its current state, modifies it, and then displays the state again.

In the `main` function, the call `mister2(mister1())` attempts to pass a temporary object returned by `mister1()` to `mister2`. However, this results in a compilation error because a non-const reference cannot bind to a temporary object (an rvalue).

### Fixing the Code

To fix the code, you can either:
1. Change the parameter of `mister2` to accept a const reference:
   ```cpp
   void mister2(const problema& o)
   {
       o.afiseaza();
       // o.schimba(); // This line would now cause a compilation error
       o.afiseaza();
   }
   ```
   However, this would prevent `mister2` from modifying the object.

2. Or, create a named object before passing it to `mister2`:
   ```cpp
   int main()
   {
       problema obj = mister1();
       mister2(obj);
       return 0;
   }
   ```

### Simpler Example to Illustrate the Concept

Consider the following simpler example:

```cpp
void printValue(int& value) {
    cout << value << endl;
}

int main() {
    printValue(5); // Error: cannot bind non-const lvalue reference to an rvalue
    return 0;
}
```

In this example, `printValue` expects a non-const reference to an `int`, but `5` is a temporary value (an rvalue), leading to a similar compilation error. To fix it, you can either change the parameter to a const reference or pass a named variable:

```cpp
void printValue(const int& value) {
    cout << value << endl;
}

int main() {
    int x = 5;
    printValue(x); // Works fine
    return 0;
}
```

This example illustrates the same concept of const-correctness and the difference between lvalues and rvalues in C++.