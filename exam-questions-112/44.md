# C++ Code Documentation

## Code
```cpp
#include<iostream>
#include<typeinfo>
using namespace std;

class B
{
    int i;
public:
    B() { i=1;}
    int get_i() {return i;}
};

class D: public B
{
    int j;
public:
    D() {j=2;}
    int get_j(){return j;}
};

int main()
{
    B *p=new D;
    cout<<p->get_i();
    if(typeid((B*)p).name()=="D*") cout<<((D*)p)->get_j();
    return 0;
}
```

## Output
```
1
```

---

## Explanation of the Code

### 1. **Class and Object Concepts** üß©
- The code defines two classes: `B` (base class) and `D` (derived class).
- An object of type `D` is created dynamically using `new D`, and its address is stored in a pointer of type `B*`.

### 2. **Inheritance** üß¨
- Class `D` inherits from class `B`. This means `D` has access to the public and protected members of `B`.
- In this case, `D` inherits the `get_i()` method from `B`.

### 3. **Encapsulation** üîí
- Both classes use encapsulation by making their data members (`i` and `j`) private. Access to these members is provided through public methods (`get_i()` and `get_j()`).

### 4. **Constructors** üèóÔ∏è
- Both classes have constructors:
  - `B()` initializes `i` to 1.
  - `D()` initializes `j` to 2 and implicitly calls the constructor of `B`.

### 5. **Polymorphism** üé≠
- The pointer `p` is of type `B*` but points to an object of type `D`. This is an example of **upcasting**.
- However, the code does not use **virtual functions**, so **dynamic polymorphism** is not demonstrated here.

### 6. **Run-Time Type Information (RTTI)** üîç
- The `typeid` operator is used to check the type of the object pointed to by `p`.
- The condition `if(typeid((B*)p).name()=="D*")` checks if the object is of type `D`. However, this condition is flawed because `typeid((B*)p).name()` returns the type of the pointer (`B*`), not the object it points to (`D`). This is why the output does not include `2`.

### 7. **Memory Management** üß†
- The `new` operator is used to dynamically allocate memory for an object of type `D`. However, the code does not release this memory using `delete`, leading to a memory leak.

---

## Concepts Used
1. [[Class and Object concepts]]
2. [[Inheritance]]
3. [[Encapsulation]]
4. [[Constructors]]
5. [[Polymorphism]]
6. [[Run-Time Type Information (RTTI) in C++ üßê]]
7. [[Memory Management]]

---

## Issues in the Code
1. **Memory Leak**: The dynamically allocated memory for `D` is not freed.
2. **Incorrect RTTI Usage**: The `typeid` check is flawed because it checks the type of the pointer (`B*`) instead of the object (`D`).

---

## Corrected Code
Here‚Äôs a corrected version of the code:
```cpp
#include<iostream>
#include<typeinfo>
using namespace std;

class B
{
    int i;
public:
    B() { i=1;}
    virtual ~B() {} // Virtual destructor for proper cleanup
    int get_i() {return i;}
};

class D: public B
{
    int j;
public:
    D() {j=2;}
    int get_j(){return j;}
};

int main()
{
    B *p=new D;
    cout<<p->get_i();
    if(typeid(*p)==typeid(D)) cout<<((D*)p)->get_j(); // Correct RTTI usage
    delete p; // Free memory
    return 0;
}
```

### Output of Corrected Code
```
12
```

---

## Simpler Example for RTTI
Here‚Äôs a simpler example to demonstrate [[Run-Time Type Information (RTTI) in C++ üßê]]:
```cpp
#include<iostream>
#include<typeinfo>
using namespace std;

class Animal {
public:
    virtual ~Animal() {} // Virtual destructor for RTTI
};

class Dog : public Animal {};

int main() {
    Animal* a = new Dog;
    if (typeid(*a) == typeid(Dog)) {
        cout << "It's a Dog!" << endl;
    }
    delete a;
    return 0;
}
```

### Output
```
It's a Dog!
```

This example correctly uses RTTI to identify the object type at runtime. üê∂

---

## Key Takeaways
- Use [[virtual functions]] and [[virtual destructors]] for proper polymorphism and cleanup.
- Be cautious with [[Run-Time Type Information (RTTI) in C++ üßê]] to avoid incorrect type checks.
- Always manage [[Memory Management]] properly to avoid leaks. üöÄ