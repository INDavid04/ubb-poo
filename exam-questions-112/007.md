# C++ Code Documentation ðŸ“„

## Code
```cpp
#include <iostream> // #include <iostream.h>
#include <typeinfo>
class B {
    int i;

public:
    B() { i = 1; }
    int get_i() { return i; }
};
class D : B {
    int j;

public:
    D() { j = 2; }
    int get_j() { return j; }
};
int main()
{
    B* p = new D;
    std::cout << p->get_i();
    if (typeid((B*)p).name() == "D*")
        std::cout << ((D*)p)->get_j();
    return 0;
}
```

## Output
```
07.cpp: In function â€˜int main()â€™:
07.cpp:19:16: error: â€˜Bâ€™ is an inaccessible base of â€˜Dâ€™
   19 |     B* p = new D;
      |                ^
```

## Code Analysis and Concepts Used ðŸ§ 
- 

## Conclusion
- Eroare la linia 19, cand apeleaza new D nu are acces la baza B (fiind protected), facem mostenirea `publica class D: public B{` iar ca rezultat ne da 1(pt ca typeid.name nu e D*, e cv gen P1D si deci nu afiseaza 2-ul). Daca era obiect ( D a nu crapa, dar crapa la cout<<a.get_i() din acelasi motiv) de revizuit
