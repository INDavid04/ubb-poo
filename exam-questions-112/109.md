# Code Documentation

## Code
```cpp
#include <iostream>
using namespace std;

struct X {
    int i;
public:
    X(int ii) { i = ii; };
    int f1() { return i; }
    X f2() const { int i = this->f1(); return X(34 - i); }
};

const X f3() { return X(16); }

int f4(const X& x) { return x.f1(); }

int main() {
    X ob(11);
    cout << f4(ob.f2().f1());
    return 0;
}
```

## Output
```
Compilation Error:
C:\Users\drago\Downloads\mihainsto FMI master Year%201%20Sem%202-pooExamQuestions_probleme\Year 1 Sem 2\pooExamQuestions\probleme\109.cpp: In member function 'X X::f2() const':
C:\Users\drago\Downloads\mihainsto FMI master Year%201%20Sem%202-pooExamQuestions_probleme\Year 1 Sem 2\pooExamQuestions\probleme\109.cpp:6:33: error: passing 'const X' as 'this' argument discards qualifiers [-fpermissive]
 X f2() const {   int i=this->f1(); return X(34-i); }};
                                 ^
C:\Users\drago\Downloads\mihainsto FMI master Year%201%20Sem%202-pooExamQuestions_probleme\Year 1 Sem 2\pooExamQuestions\probleme\109.cpp:5:10: note:   in call to 'int X::f1()'
      int f1() { return i; }
          ^~
C:\Users\drago\Downloads\mihainsto FMI master Year%201%20Sem%202-pooExamQuestions_probleme\Year 1 Sem 2\pooExamQuestions\probleme\109.cpp: In function 'int f4(const X&)':
C:\Users\drago\Downloads\mihainsto FMI master Year%201%20Sem%202-pooExamQuestions_probleme\Year 1 Sem 2\pooExamQuestions\probleme\109.cpp:8:34: error: passing 'const X' as 'this' argument discards qualifiers [-fpermissive]
 int f4(const X& x) { return x.f1(); }
                                  ^
C:\Users\drago\Downloads\mihainsto FMI master Year%201%20Sem%202-pooExamQuestions_probleme\Year 1 Sem 2\pooExamQuestions\probleme\109.cpp:5:10: note:   in call to 'int X::f1()'
      int f1() { return i; }
          ^~
```

## Concepts Used

### [[Class and Object concepts]] üßê
- The code defines a `struct X`, which is essentially a class in C++ with public members by default. The `struct X` has a data member `i` and member functions `f1()` and `f2()`.
- An object `ob` of type `X` is created in the `main()` function.

### [[Encapsulation]] üõ°Ô∏è
- The `struct X` encapsulates the data member `i` and the member functions `f1()` and `f2()`. However, since `i` is public, it doesn't fully adhere to the principle of encapsulation, which typically involves making data members private.

### [[Constructors]] üî®
- The `struct X` has a constructor `X(int ii)` that initializes the data member `i` with the value passed to it.

### [[Const-correctness & code clarity]] üßº
- The function `f2()` is marked as `const`, indicating that it does not modify the state of the object. However, it calls `f1()`, which is not marked as `const`. This leads to a compilation error because a `const` member function cannot call a non-`const` member function.
- Similarly, `f4()` takes a `const X&` as a parameter and tries to call `f1()`, which is not `const`, resulting in another compilation error.

### [[Data Members]] üìä
- The `struct X` has a single data member `i`, which is an integer.

### [[Revisiting C language constructs (struct, pointers, arrays) and how they map into C++ classes and methods]] üîÑ
- The `struct X` is a C-style struct but is used in a C++ context with member functions. In C++, structs can have member functions, just like classes, but the default access specifier is public.

## Explanation of Errors

### Error 1: `f2()` calling `f1()`
- The function `f2()` is marked as `const`, meaning it promises not to modify the object. However, it calls `f1()`, which is not marked as `const`. This is a violation of [[Const-correctness & code clarity]] because `f1()` could potentially modify the object, which is not allowed in a `const` context.

### Error 2: `f4()` calling `f1()`
- The function `f4()` takes a `const X&` as a parameter, meaning it promises not to modify the object passed to it. However, it calls `f1()`, which is not marked as `const`. This again violates [[Const-correctness & code clarity]].

## Fixing the Code

To fix the code, we need to ensure that `f1()` is marked as `const` since it does not modify the object:

```cpp
#include <iostream>
using namespace std;

struct X {
    int i;
public:
    X(int ii) { i = ii; };
    int f1() const { return i; }  // Marked as const
    X f2() const { int i = this->f1(); return X(34 - i); }
};

const X f3() { return X(16); }

int f4(const X& x) { return x.f1(); }

int main() {
    X ob(11);
    cout << f4(ob.f2().f1());
    return 0;
}
```

### Explanation of Fix
- By marking `f1()` as `const`, we ensure that it can be called from `f2()` and `f4()` without violating [[Const-correctness & code clarity]]. This makes the code compile successfully.

## Simpler Example to Illustrate [[Const-correctness & code clarity]]

Consider the following simpler example:

```cpp
class MyClass {
    int value;
public:
    MyClass(int v) : value(v) {}
    int getValue() { return value; }  // Not const
    void printValue() const {
        cout << getValue();  // Error: getValue() is not const
    }
};
```

To fix this, we need to mark `getValue()` as `const`:

```cpp
class MyClass {
    int value;
public:
    MyClass(int v) : value(v) {}
    int getValue() const { return value; }  // Marked as const
    void printValue() const {
        cout << getValue();  // Now it works
    }
};
```

This example demonstrates the importance of [[Const-correctness & code clarity]] in ensuring that `const` member functions do not call non-`const` member functions.