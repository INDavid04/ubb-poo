# Code Documentation

## Code
```cpp
#include <iostream>
using namespace std;

class B {
    int i;

public:
    B() { i = 1; }
    int get_i() { return i; }
};
class D : public B {
    int j;

public:
    D() { j = 2; }
    int get_j() { return j; }
};
int main()
{
    B* p;
    int x = 0;
    if (x)
        p = new B;
    else
        p = new D;
    if (typeid(p).name() == "D*")
        cout << ((D*)p)->get_j();
    return 0;
}
```

## Output
```
Compilation Error:
C:\Users\drago\Downloads\mihainsto FMI master Year%201%20Sem%202-pooExamQuestions_probleme\Year 1 Sem 2\pooExamQuestions\probleme\88.cpp: In function 'int main()':
C:\Users\drago\Downloads\mihainsto FMI master Year%201%20Sem%202-pooExamQuestions_probleme\Year 1 Sem 2\pooExamQuestions\probleme\88.cpp:26:16: error: must #include <typeinfo> before using typeid
     if (typeid(p).name() == "D*")
                ^
```

## Explanation

### Concepts Used

1. **[[Class and Object concepts]]** üèóÔ∏è
   - The code defines two classes: `B` and `D`. 
   - `B` is a base class with a private data member `i` and a public method `get_i()`.
   - `D` is a derived class that inherits from `B` and adds its own private data member `j` and a public method `get_j()`.

2. **[[Inheritance]]** üß¨
   - Class `D` inherits from class `B`. This means `D` has access to the public and protected members of `B`.
   - Example:
     ```cpp
     class D : public B {
         // D inherits from B
     };
     ```

3. **[[Constructors]]** üî®
   - Both classes `B` and `D` have constructors that initialize their respective data members.
   - `B()` initializes `i` to 1.
   - `D()` initializes `j` to 2.

4. **[[Memory Management]]** üß†
   - The code uses `new` to dynamically allocate memory for objects of type `B` or `D`.
   - Example:
     ```cpp
     p = new B;  // Allocates memory for a B object
     p = new D;  // Allocates memory for a D object
     ```

5. **[[Run-Time Type Information (RTTI) in C++]]** üïµÔ∏è‚Äç‚ôÇÔ∏è
   - The code attempts to use `typeid` to check the type of the object pointed to by `p`.
   - However, the code fails to compile because it doesn't include the `<typeinfo>` header, which is necessary for using `typeid`.
   - Correct usage would require:
     ```cpp
     #include <typeinfo>
     ```

### Issues and Fixes

- **Compilation Error**: The error occurs because the `<typeinfo>` header is missing. This header is required for using `typeid` in C++.
- **Fix**: Add `#include <typeinfo>` at the beginning of the code.
  ```cpp
  #include <typeinfo>
  ```

### Corrected Code
```cpp
#include <iostream>
#include <typeinfo>  // Required for typeid
using namespace std;

class B {
    int i;

public:
    B() { i = 1; }
    int get_i() { return i; }
};
class D : public B {
    int j;

public:
    D() { j = 2; }
    int get_j() { return j; }
};
int main()
{
    B* p;
    int x = 0;
    if (x)
        p = new B;
    else
        p = new D;
    if (typeid(*p) == typeid(D))  // Correct usage of typeid
        cout << ((D*)p)->get_j();
    return 0;
}
```

### Additional Notes

- **[[Polymorphism]]** üé≠: The code could be improved to use polymorphism by making `get_i()` and `get_j()` virtual functions. This would allow dynamic binding and more flexible code.
- **[[Encapsulation]]** üõ°Ô∏è: The data members `i` and `j` are private, which is good practice as it encapsulates the data and prevents direct access from outside the class.

### Simpler Example for [[Run-Time Type Information (RTTI) in C++]] üïµÔ∏è‚Äç‚ôÇÔ∏è
```cpp
#include <iostream>
#include <typeinfo>
using namespace std;

class Animal {
public:
    virtual void sound() { cout << "Animal sound" << endl; }
};

class Dog : public Animal {
public:
    void sound() override { cout << "Bark" << endl; }
};

int main() {
    Animal* a = new Dog();
    if (typeid(*a) == typeid(Dog)) {
        cout << "a is a Dog" << endl;
    }
    return 0;
}
```
In this example, `typeid` is used to check if the object `a` is of type `Dog`.

---

This documentation should help you understand the code and the concepts involved. If you have any more questions, feel free to ask! üòä