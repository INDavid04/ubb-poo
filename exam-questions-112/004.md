# C++ Code Documentation ðŸ“„

## Code
```cpp
#include <iostream> 
class problema {
    int i;

public:
    problema(int j = 5) { i = j; }
    void schimba() { i++; }
    void afiseaza() { std::cout << "starea curenta " << i << "\n"; }
};
problema mister1() { return problema(6); }
void mister2(problema& o)
{
    o.afiseaza(); 
    o.schimba();
    o.afiseaza(); 
}
int main()
{
    mister2(mister1());

    return 0;
}
```

## MyCode
```cpp
```cpp
#include <iostream> 
class problema {
    int i;

public:
    problema(int j = 5) { i = j; }
    void schimba() { i++; }
    void afiseaza() { std::cout << "starea curenta " << i << "\n"; }
};
problema mister1() { return problema(6); }
void mister2(problema& o)
{
    o.afiseaza(); /// out "starea curenta 6\n"
    o.schimba(); /// o.i = 7
    o.afiseaza(); /// out << "starea curenta 7\n"
}
int main()
{
    mister2(mister1());

    /// mister2(mister1()) = mister2(problema(6)) /// o.i = 6

    return 0;
}
```

## Output
```
04.cpp: In function â€˜int main()â€™:
04.cpp:19:20: error: cannot bind non-const lvalue reference of type â€˜problema&â€™ to an rvalue of type â€˜problemaâ€™
   19 |     mister2(mister1());
      |             ~~~~~~~^~
04.cpp:11:24: note:   initializing argument 1 of â€˜void mister2(problema&)â€™
   11 | void mister2(problema& o)
      |              ~~~~~~~~~~^
```

## Code Analysis and Concepts Used ðŸ§ 
- Obiect temporar si referinta
ðŸ‘‰ mister2(mister1()); â†’ mister1() creeazÄƒ un temporar, mister2() primeÈ™te referinÈ›Äƒ.
ðŸ“Œ Èšine minte: Un temporar poate fi dat ca parametru prin referinÈ›Äƒ la funcÈ›ie.

## Conclusion
- Linia 20, nu putem parsa obiect de tip problema in functie mister2 ce primeste adresa de memorie, stergem& la void mister2(persoana& o)
