# C++ Code Documentation 📄

## Code
```cpp
#include <iostream>
using namespace std;

template <class T>
int f(T x, T y)
{
    return x + y;
}
int f(int x, int y)
{
    return x - y;
}
int main()
{
    int a = 5;
    float b = 8.6;
    cout << f(a, b);
    return 0;
}
```

## Output
```
-3
```

---

## Explanation of the Code 🧠

### 1. **Function Overloading** 🔄
The code defines two functions named `f`:
- A **template function** `f(T x, T y)` that adds two values of the same type `T`.
- A **non-template function** `f(int x, int y)` that subtracts two integers.

This is an example of [[Function Overloading]], where multiple functions share the same name but have different parameter types or numbers.

### 2. **Template Function** 🧩
The template function:
```cpp
template <class T>
int f(T x, T y)
{
    return x + y;
}
```
is a [[Templates & Generic Programming]] feature. It allows the function to work with any data type `T` (e.g., `int`, `float`, `double`). However, in this case, the template function is not used because the non-template function is a better match for the arguments provided.

### 3. **Type Deduction and Function Selection** 🔍
In the `main()` function:
```cpp
int a = 5;
float b = 8.6;
cout << f(a, b);
```
- `a` is an `int`, and `b` is a `float`.
- The compiler tries to find the best match for `f(a, b)`.
- Since the template function requires both arguments to be of the same type (`T`), it cannot be used here.
- Instead, the non-template function `f(int x, int y)` is selected because `int` is a closer match for `a` and `b` than the template function.

### 4. **Implicit Type Conversion** 🔄
When `f(a, b)` is called:
- The `float` value `b` is implicitly converted to an `int` (truncating it to `8`).
- The non-template function `f(int x, int y)` performs `5 - 8`, resulting in `-3`.

This demonstrates [[Implicit Type Conversion]], where the compiler automatically converts one data type to another to match the function signature.

---

## Key Concepts Used 🛠️

1. [[Function Overloading]]: Multiple functions with the same name but different parameters.
2. [[Templates & Generic Programming]]: Writing generic code that works with any data type.
3. [[Implicit Type Conversion]]: Automatic conversion of one data type to another.

---

## Simpler Example to Illustrate [[Function Overloading]] 🎯

```cpp
#include <iostream>
using namespace std;

void print(int x) {
    cout << "Integer: " << x << endl;
}

void print(double x) {
    cout << "Double: " << x << endl;
}

int main() {
    print(5);       // Calls print(int x)
    print(3.14);    // Calls print(double x)
    return 0;
}
```

### Output:
```
Integer: 5
Double: 3.14
```

Here, the `print` function is overloaded to handle both `int` and `double` types. The compiler selects the appropriate function based on the argument type.

---

## Why the Output is `-3` 🤔

- The non-template function `f(int x, int y)` is called because it matches the argument types better than the template function.
- `b` (a `float`) is implicitly converted to an `int` (truncating `8.6` to `8`).
- The function performs `5 - 8`, resulting in `-3`.

---

## Summary 📝

This code demonstrates:
- [[Function Overloading]]: Multiple functions with the same name but different parameters.
- [[Templates & Generic Programming]]: Writing generic functions that work with any data type.
- [[Implicit Type Conversion]]: Automatic conversion of data types to match function signatures.

The output `-3` is a result of the non-template function being selected and implicit type conversion of the `float` argument to an `int`. 🎉