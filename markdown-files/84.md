# Code Documentation 📄

## Code
```cpp
#include <iostream>
using namespace std;

class B {
    static int x;
    int i;

public:
    B()
    {
        x++;
        i = 1;
    }
    ~B() { x--; }
    static int get_x() { return x; }
    int get_i() { return i; }
};
int B::x;
class D : public B {
public:
    D() { x++; }
    ~D() { x--; }
};
int f(B* q)
{
    return (q->get_i()) + 1;
}
int main()
{
    B* p = new B;
    cout << f(p);
    delete p;
    p = new D;
    cout << f(p);
    delete p;
    cout << D::get_x();
    return 0;
}
```

## Output
```
Compilation Error:
C:\Users\drago\Downloads\mihainsto FMI master Year%201%20Sem%202-pooExamQuestions_probleme\Year 1 Sem 2\pooExamQuestions\probleme\84.cpp: In constructor 'D::D()':
C:\Users\drago\Downloads\mihainsto FMI master Year%201%20Sem%202-pooExamQuestions_probleme\Year 1 Sem 2\pooExamQuestions\probleme\84.cpp:21:11: error: 'int B::x' is private within this context
     D() { x++; }
           ^
C:\Users\drago\Downloads\mihainsto FMI master Year%201%20Sem%202-pooExamQuestions_probleme\Year 1 Sem 2\pooExamQuestions\probleme\84.cpp:18:5: note: declared private here
 int B::x;
     ^
C:\Users\drago\Downloads\mihainsto FMI master Year%201%20Sem%202-pooExamQuestions_probleme\Year 1 Sem 2\pooExamQuestions\probleme\84.cpp: In destructor 'D::~D()':
C:\Users\drago\Downloads\mihainsto FMI master Year%201%20Sem%202-pooExamQuestions_probleme\Year 1 Sem 2\pooExamQuestions\probleme\84.cpp:22:12: error: 'int B::x' is private within this context
     ~D() { x--; }
            ^
C:\Users\drago\Downloads\mihainsto FMI master Year%201%20Sem%202-pooExamQuestions_probleme\Year 1 Sem 2\pooExamQuestions\probleme\84.cpp:18:5: note: declared private here
 int B::x;
     ^
```

## Concepts Used 🧠

### [[Class and Object concepts]]
- The code defines a class `B` and a derived class `D`. These classes encapsulate data and behavior.
- An object of class `B` is created in the `main` function using `new B`, and similarly, an object of class `D` is created using `new D`.

### [[Encapsulation]]
- The data member `x` in class `B` is declared as `private`, which means it cannot be accessed directly outside the class. This is a key aspect of encapsulation, where the internal state of an object is hidden from the outside world.
- The error in the code occurs because `x` is private in `B`, and the derived class `D` tries to access it directly.

### [[Inheritance]]
- Class `D` inherits from class `B`. This means `D` will have access to the public and protected members of `B`.
- However, since `x` is private in `B`, `D` cannot access it directly, leading to the compilation error.

### [[Data Members]]
- `x` is a static data member of class `B`, meaning it is shared across all instances of `B` and its derived classes.
- `i` is a non-static data member, unique to each instance of `B`.

### [[Constructors]]
- Both `B` and `D` have constructors. The constructor of `B` increments the static member `x` and initializes `i` to 1.
- The constructor of `D` attempts to increment `x`, but fails due to `x` being private in `B`.

### [[Destructors]]
- Both `B` and `D` have destructors. The destructor of `B` decrements the static member `x`.
- The destructor of `D` attempts to decrement `x`, but fails due to `x` being private in `B`.

### [[Memory Management]]
- The code uses `new` and `delete` to dynamically allocate and deallocate memory for objects of classes `B` and `D`.

### [[Static Members]]
- `x` is a static member of class `B`, meaning it is shared across all instances of `B` and its derived classes. Static members are initialized outside the class definition, as seen with `int B::x;`.

### [[Access Specifiers]]
- The `private` access specifier in class `B` restricts access to `x` to only within the class `B`. This is why the derived class `D` cannot access `x` directly.

## Fixing the Code 🛠️

To fix the code, we need to make `x` accessible to the derived class `D`. This can be done by changing the access specifier of `x` to `protected`:

```cpp
class B {
protected:
    static int x;
    int i;

public:
    B()
    {
        x++;
        i = 1;
    }
    ~B() { x--; }
    static int get_x() { return x; }
    int get_i() { return i; }
};
int B::x;
```

Now, `D` can access `x` without any issues:

```cpp
class D : public B {
public:
    D() { x++; }
    ~D() { x--; }
};
```

With this change, the code will compile and run correctly, producing the expected output.

## Simpler Example to Illustrate [[Inheritance]] and [[Access Specifiers]]

Consider the following simpler example:

```cpp
#include <iostream>
using namespace std;

class Base {
protected:
    int x;
public:
    Base() : x(0) {}
    void setX(int val) { x = val; }
    int getX() { return x; }
};

class Derived : public Base {
public:
    void incrementX() { x++; }
};

int main() {
    Derived d;
    d.setX(10);
    d.incrementX();
    cout << d.getX(); // Output: 11
    return 0;
}
```

In this example:
- `x` is declared as `protected` in `Base`, so `Derived` can access it directly.
- `Derived` inherits from `Base` and can modify `x` using the `incrementX` method.

This demonstrates how [[Inheritance]] and [[Access Specifiers]] work together in C++. 🎉