# Code Documentation

## Code
```cpp
#include <iostream>
using namespace std;

class B {
    int i;
public:
    B() { i = 80; }
    virtual int get_i() { return i; }
};

class D : public B {
    int j;
public:
    D() { j = 27; }
    int get_j() { return j; }
};

int main() {
    D *p = new B;
    cout << p->get_i();
    cout << ((D*)p)->get_j();
    return 0;
}
```

## Output
```
Compilation Error:
C:\Users\drago\Downloads\mihainsto FMI master Year%201%20Sem%202-pooExamQuestions_probleme\Year 1 Sem 2\pooExamQuestions\probleme\103.cpp: In function 'int main()':
C:\Users\drago\Downloads\mihainsto FMI master Year%201%20Sem%202-pooExamQuestions_probleme\Year 1 Sem 2\pooExamQuestions\probleme\103.cpp:14:12: error: invalid conversion from 'B*' to 'D*' [-fpermissive]
 { D *p = new B;
            ^
```

## Explanation

### Concepts Used

1. **[Class and Object concepts]**: The code defines two classes, `B` and `D`. An object of class `B` is created in the `main` function.
2. **[Inheritance]**: Class `D` inherits from class `B`. This means `D` has access to the public and protected members of `B`.
3. **[Encapsulation]**: The data members `i` and `j` are private, meaning they can only be accessed within their respective classes or through public methods.
4. **[Polymorphism]**: The `get_i` method in class `B` is marked as `virtual`, allowing it to be overridden in derived classes. However, in this code, `D` does not override `get_i`.
5. **[Constructors]**: Both classes `B` and `D` have constructors that initialize their respective data members.
6. **[Memory Management]**: The `new` operator is used to dynamically allocate memory for an object of type `B`.

### Detailed Analysis

The code attempts to create an object of type `B` and assign it to a pointer of type `D*`. This is incorrect because a pointer to a derived class (`D*`) cannot point to an object of the base class (`B`). This is a violation of the type system in C++.

#### Corrected Code Example
To fix the code, you should create an object of type `D` and assign it to a pointer of type `D*`:

```cpp
#include <iostream>
using namespace std;

class B {
    int i;
public:
    B() { i = 80; }
    virtual int get_i() { return i; }
};

class D : public B {
    int j;
public:
    D() { j = 27; }
    int get_j() { return j; }
};

int main() {
    D *p = new D;  // Corrected: Create an object of type D
    cout << p->get_i() << endl;  // Output: 80
    cout << p->get_j() << endl;  // Output: 27
    delete p;  // Don't forget to free the allocated memory
    return 0;
}
```

### Additional Concepts

- **[Run-Time Type Information (RTTI) in C++ 🧐]**: Although not used in this code, RTTI could be used to check the type of an object at runtime, which might help in debugging or handling polymorphic objects.
- **[Const-correctness & code clarity]**: Ensuring that pointers and references are correctly marked as `const` where appropriate can prevent unintended modifications and improve code clarity.
- **[Exception-safe design]**: Proper memory management and exception handling should be considered, especially when dealing with dynamic memory allocation.

### Simpler Example to Illustrate Inheritance

```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    void eat() {
        cout << "Animal is eating" << endl;
    }
};

class Dog : public Animal {
public:
    void bark() {
        cout << "Dog is barking" << endl;
    }
};

int main() {
    Dog myDog;
    myDog.eat();  // Inherited from Animal
    myDog.bark(); // Specific to Dog
    return 0;
}
```

In this example, `Dog` inherits from `Animal`, allowing `Dog` to use the `eat` method defined in `Animal`. This demonstrates how [[Inheritance]] allows derived classes to reuse code from base classes.

### Conclusion

The original code has a type mismatch error due to incorrect pointer assignment. Understanding [[Class and Object concepts]], [[Inheritance]], and [[Memory Management]] is crucial to avoid such errors. Always ensure that pointers are correctly typed and that objects are properly instantiated. 🚀