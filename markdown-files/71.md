# C++ Code Documentation 📄

## Code
```cpp
#include <iostream>

class cls1 {
    int x;

public:
    cls1() { x = 13; }
    int g()
    {
        static int i;
        i++;
        return (i + x);
    }
};
class cls2 {
    int x;

public:
    cls2() { x = 27; }
    cls1& f()
    {
        static cls1 ob;
        return ob;
    }
};
int main()
{
    cls2 ob;
    cout << ob.f().g();
    return 0;
}
```

## Output
```
Compilation Error:
C:\Users\drago\Downloads\mihainsto FMI master Year%201%20Sem%202-pooExamQuestions_probleme\Year 1 Sem 2\pooExamQuestions\probleme\71.cpp: In function 'int main()':
C:\Users\drago\Downloads\mihainsto FMI master Year%201%20Sem%202-pooExamQuestions_probleme\Year 1 Sem 2\pooExamQuestions\probleme\71.cpp:29:5: error: 'cout' was not declared in this scope
     cout << ob.f().g();
     ^~~~
C:\Users\drago\Downloads\mihainsto FMI master Year%201%20Sem%202-pooExamQuestions_probleme\Year 1 Sem 2\pooExamQuestions\probleme\71.cpp:29:5: note: suggested alternative:
In file included from C:\Users\drago\Downloads\mihainsto FMI master Year%201%20Sem%202-pooExamQuestions_probleme\Year 1 Sem 2\pooExamQuestions\probleme\71.cpp:1:0:
c:\mingw\lib\gcc\mingw32\6.3.0\include\c++\iostream:61:18: note:   'std::cout'
   extern ostream cout;  /// Linked to standard output
                  ^~~~
```

---

## Code Explanation 🧐

### 1. **Class and Object Concepts** [[Class and Object concepts]]
   - The code defines two classes: `cls1` and `cls2`.
   - `cls1` has a private data member `x` and a public method `g()`.
   - `cls2` also has a private data member `x` and a public method `f()`.
   - In `main()`, an object `ob` of type `cls2` is created.

### 2. **Encapsulation** [[Encapsulation]]
   - Both `cls1` and `cls2` encapsulate their data members (`x`) by making them private. This ensures that the data can only be accessed or modified through public methods.

### 3. **Constructors** [[Constructors]]
   - Both classes have constructors:
     - `cls1()` initializes `x` to 13.
     - `cls2()` initializes `x` to 27.
   - Constructors are automatically called when an object of the class is created.

### 4. **Static Variables** [[Static Variables]]
   - In `cls1::g()`, a static variable `i` is used. Static variables retain their value between function calls.
   - In `cls2::f()`, a static object `ob` of type `cls1` is used. This ensures that the same object is returned every time `f()` is called.

### 5. **Scope Resolution and Namespace** [[Namespace]]
   - The compilation error occurs because `cout` is not declared in the global scope. `cout` is part of the `std` namespace, so it should be used as `std::cout`.
   - Fix: Replace `cout` with `std::cout` in `main()`.

### 6. **Singleton-like Behavior** [[Singleton]]
   - The method `cls2::f()` returns a static instance of `cls1`. This ensures that the same object is returned every time `f()` is called, similar to a [[Singleton]] pattern.

---

## Fixed Code
```cpp
#include <iostream>

class cls1 {
    int x;

public:
    cls1() { x = 13; }
    int g()
    {
        static int i;
        i++;
        return (i + x);
    }
};
class cls2 {
    int x;

public:
    cls2() { x = 27; }
    cls1& f()
    {
        static cls1 ob;
        return ob;
    }
};
int main()
{
    cls2 ob;
    std::cout << ob.f().g(); // Fixed: Added std::
    return 0;
}
```

---

## Concepts Used 🚀
1. [[Class and Object concepts]] - Classes `cls1` and `cls2` are defined, and objects are created.
2. [[Encapsulation]] - Data members are private, and access is controlled via public methods.
3. [[Constructors]] - Constructors initialize data members when objects are created.
4. [[Static Variables]] - Static variables retain their values between function calls.
5. [[Namespace]] - `std::cout` is used to resolve the scope issue.
6. [[Singleton]] - The method `cls2::f()` returns a static instance of `cls1`, ensuring a single instance is used.

---

## Simpler Example for Static Variables
```cpp
#include <iostream>

void counter() {
    static int count = 0; // Static variable retains its value
    count++;
    std::cout << "Count: " << count << std::endl;
}

int main() {
    counter(); // Output: Count: 1
    counter(); // Output: Count: 2
    counter(); // Output: Count: 3
    return 0;
}
```
- Here, the static variable `count` retains its value between function calls, similar to the static variable `i` in `cls1::g()`.

---

## Summary
The code demonstrates basic [[Class and Object concepts]], [[Encapsulation]], and the use of [[Static Variables]] and [[Constructors]]. The compilation error is resolved by correctly using the `std::cout` from the `std` [[Namespace]]. The design also hints at a [[Singleton]]-like behavior with the static object in `cls2::f()`. 🎉