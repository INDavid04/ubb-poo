# Code Documentation

## Code
```cpp
#include<iostream>
using namespace std;

class A
{
    int i;
public: 
    A() { i = 1; }
    virtual int get_i() { return i; }
};

class B : public A
{
    int j;
public: 
    B() { j = 2; }
    int get_i() { return A::get_i() + j; }
};

int main()
{
    const int i = cin.get();
    if (i % 3) { A o; }
    else { B o; }
    cout << o.get_i();
    return 0;
}
```

## Output
```
Compilation Error:
C:\Users\drago\Downloads\mihainsto FMI master Year%201%20Sem%202-pooExamQuestions_probleme\Year 1 Sem 2\pooExamQuestions\probleme\42.cpp: In function 'int main()':
C:\Users\drago\Downloads\mihainsto FMI master Year%201%20Sem%202-pooExamQuestions_probleme\Year 1 Sem 2\pooExamQuestions\probleme\42.cpp:20:11: error: 'o' was not declared in this scope
     cout<<o.get_i();
           ^
```

## Explanation

### Concepts Used

1. **[[Class and Object concepts]]** üßê  
   The code defines two classes, `A` and `B`. An object of either class is created in the `main` function based on user input. However, the object `o` is declared inside the `if` and `else` blocks, making it inaccessible outside those blocks.

2. **[[Inheritance]]** üöÄ  
   Class `B` inherits from class `A`. This means `B` has access to the public and protected members of `A`. In this case, `B` overrides the `get_i` method from `A`.

3. **[[Polymorphism]]** üßê  
   The `get_i` method in class `A` is marked as `virtual`, allowing it to be overridden in derived classes. This enables runtime polymorphism, where the correct `get_i` method is called based on the actual object type.

4. **[[Encapsulation]]** üßê  
   The data members `i` and `j` are private by default in their respective classes, encapsulating them and preventing direct access from outside the class.

5. **[[Constructors]]** üßê  
   Both classes `A` and `B` have constructors that initialize their respective data members. `A` initializes `i` to 1, and `B` initializes `j` to 2.

6. **[[Const-correctness & code clarity]]** üßê  
   The variable `i` in the `main` function is declared as `const`, indicating that its value should not change after initialization.

### Issues in the Code

The main issue in the code is related to **[[scope]]**. The object `o` is declared inside the `if` and `else` blocks, making it inaccessible outside those blocks. This results in a compilation error when trying to call `o.get_i()` outside the blocks.

### Fixing the Code

To fix the code, we need to declare the object `o` outside the `if` and `else` blocks. However, since `o` can be either of type `A` or `B`, we need to use a pointer or reference to achieve this. Here‚Äôs a corrected version:

```cpp
#include<iostream>
using namespace std;

class A
{
    int i;
public: 
    A() { i = 1; }
    virtual int get_i() { return i; }
};

class B : public A
{
    int j;
public: 
    B() { j = 2; }
    int get_i() override { return A::get_i() + j; }
};

int main()
{
    const int i = cin.get();
    A* o;
    if (i % 3) { o = new A(); }
    else { o = new B(); }
    cout << o->get_i();
    delete o;
    return 0;
}
```

### Explanation of the Fix

1. **[[Memory Management]]** üßê  
   We use dynamic memory allocation (`new`) to create objects of type `A` or `B` and store them in a pointer of type `A*`. This allows us to access the object outside the `if` and `else` blocks.

2. **[[Polymorphism]]** üßê  
   The pointer `o` of type `A*` can point to either an `A` object or a `B` object. When `get_i()` is called, the correct version of the method is invoked based on the actual object type, demonstrating runtime polymorphism.

3. **[[Destructors]]** üßê  
   Although not explicitly shown, it‚Äôs important to delete the dynamically allocated object to avoid memory leaks. In this case, `delete o;` is used to free the memory.

### Simpler Example to Illustrate [[Polymorphism]]

```cpp
#include<iostream>
using namespace std;

class Animal {
public:
    virtual void speak() { cout << "Animal sound" << endl; }
};

class Dog : public Animal {
public:
    void speak() override { cout << "Woof!" << endl; }
};

class Cat : public Animal {
public:
    void speak() override { cout << "Meow!" << endl; }
};

int main() {
    Animal* a = new Dog();
    a->speak();  // Outputs: Woof!
    delete a;

    a = new Cat();
    a->speak();  // Outputs: Meow!
    delete a;

    return 0;
}
```

In this example, the `speak` method is overridden in the `Dog` and `Cat` classes. The `Animal` pointer `a` can point to either a `Dog` or `Cat` object, and the correct `speak` method is called based on the actual object type, demonstrating [[Polymorphism]]. üê∂üê±

---

This documentation covers the key concepts and issues in the provided code, along with a simpler example to illustrate [[Polymorphism]]. üöÄ