# C++ Code Documentation üìÑ

## Code Overview

```cpp
#include <iostream>

using namespace std;

class B {
    int i;

public:
    B() { i = 1; }
    virtual int get_i() { return i; }
};

class D : virtual public B {
    int j;

public:
    D() { j = 2; }
    int get_i() { return B::get_i() + j; }
};

class D2 : virtual public B {
    int j2;

public:
    D2() { j2 = 3; }
    int get_i() { return B::get_i() + j2; }
};

class MM : public D, public D2 {
    int x;

public:
    MM() { x = D::get_i() + D2::get_i(); }
    int get_i() { return x; }
};

int main() {
    B* o = new MM();
    cout << o->get_i() << "\n";
    MM* p = dynamic_cast<MM*>(o);
    if (p)
        cout << p->get_i() << "\n";
    D* p2 = dynamic_cast<D*>(o);
    if (p2)
        cout << p2->get_i() << "\n";
    return 0;
}
```

## Output

```
7
7
7
```

---

## Code Explanation üß†

### 1. **Class and Object Concepts** [[Class and Object concepts]]
   - The code defines several classes: `B`, `D`, `D2`, and `MM`. Each class represents a blueprint for creating objects.
   - Objects are instances of these classes. For example, `B* o = new MM();` creates an object of type `MM` and assigns it to a pointer of type `B`.

### 2. **Inheritance** [[Inheritance]]
   - The classes `D` and `D2` inherit from class `B` using `virtual public B`. This ensures that there is only one instance of `B` in the `MM` class, avoiding the "diamond problem" in multiple inheritance.
   - The class `MM` inherits from both `D` and `D2`, making it a derived class with multiple base classes.

### 3. **Polymorphism** [[Polymorphism]]
   - The `get_i()` method in class `B` is declared as `virtual`, allowing derived classes to override it. This enables runtime polymorphism.
   - When `o->get_i()` is called, the overridden `get_i()` method in `MM` is executed, even though `o` is a pointer of type `B`.

### 4. **Encapsulation** [[Encapsulation]]
   - Data members like `i`, `j`, `j2`, and `x` are private by default in their respective classes. This hides the internal state of the objects and exposes only the necessary methods (`get_i()`).

### 5. **Constructors** [[Constructors]]
   - Each class has a constructor that initializes its data members:
     - `B()` initializes `i` to 1.
     - `D()` initializes `j` to 2.
     - `D2()` initializes `j2` to 3.
     - `MM()` calculates `x` as the sum of `D::get_i()` and `D2::get_i()`.

### 6. **Run-Time Type Information (RTTI)** [[Run-Time Type Information (RTTI) in C++ üßê]]
   - The `dynamic_cast` operator is used to safely cast pointers at runtime. For example:
     - `MM* p = dynamic_cast<MM*>(o);` checks if `o` is of type `MM`.
     - `D* p2 = dynamic_cast<D*>(o);` checks if `o` is of type `D`.

### 7. **Multiple Inheritance** [[Multiple Inheritance]]
   - The class `MM` inherits from both `D` and `D2`. This is an example of multiple inheritance, where a class can have more than one base class.

---

## Key Concepts in Action üõ†Ô∏è

### **Polymorphism Example**
```cpp
B* o = new MM();
cout << o->get_i() << "\n"; // Output: 7
```
- Here, `o` is a pointer of type `B`, but it points to an object of type `MM`. The `get_i()` method from `MM` is called due to polymorphism.

### **Dynamic Casting Example**
```cpp
MM* p = dynamic_cast<MM*>(o);
if (p)
    cout << p->get_i() << "\n"; // Output: 7
```
- The `dynamic_cast` checks if `o` can be safely cast to `MM*`. Since `o` is indeed an `MM` object, the cast succeeds, and `p->get_i()` is called.

---

## Simpler Example to Illustrate Polymorphism üêæ

```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    virtual void speak() { cout << "Animal sound\n"; }
};

class Dog : public Animal {
public:
    void speak() override { cout << "Woof!\n"; }
};

int main() {
    Animal* a = new Dog();
    a->speak(); // Output: Woof!
    delete a;
    return 0;
}
```
- In this example, `Animal` is the base class, and `Dog` is the derived class. The `speak()` method is overridden in `Dog`, demonstrating polymorphism.

---

## Summary of Concepts Used üìö

1. [[Class and Object concepts]]: Classes define blueprints for objects.
2. [[Inheritance]]: Classes inherit properties and behaviors from other classes.
3. [[Polymorphism]]: Overriding methods in derived classes for runtime behavior.
4. [[Encapsulation]]: Hiding internal data and exposing methods.
5. [[Constructors]]: Initializing objects when they are created.
6. [[Run-Time Type Information (RTTI) in C++ üßê]]: Using `dynamic_cast` for safe type casting.
7. [[Multiple Inheritance]]: A class inheriting from multiple base classes.

---

This code is a great example of how [[Inheritance]], [[Polymorphism]], and [[Run-Time Type Information (RTTI) in C++ üßê]] work together in C++! üöÄ