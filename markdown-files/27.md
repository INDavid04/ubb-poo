# C++ Code Documentation 📄

## Code
```cpp
#include <iostream>
using namespace std;

class B {
    int i;

public:
    B() { i = 1; }
    virtual int get_i() { return i; }
};
class D : public B {
    int j;

public:
    D() { j = 2; }
    int get_i() { return B::get_i() + j; }
};
int main()
{
    const int i = cin.get();
    if (i % 3) {
        D o;
    }
    else {
        B o;
    }
    cout << o.get_i(); //(1)
    return 0;
}
```

## Output
```
Compilation Error:
C:\Users\drago\Downloads\mihainsto FMI master Year%201%20Sem%202-pooExamQuestions_probleme\Year 1 Sem 2\pooExamQuestions\probleme\27.cpp: In function 'int main()':
C:\Users\drago\Downloads\mihainsto FMI master Year%201%20Sem%202-pooExamQuestions_probleme\Year 1 Sem 2\pooExamQuestions\probleme\27.cpp:27:13: error: 'o' was not declared in this scope
     cout << o.get_i(); //(1)
             ^
```

---

## Code Explanation 🧠

### 1. **Class and Object Concepts** [[Class and Object concepts]]
   - The code defines two classes: `B` (base class) and `D` (derived class).
   - An **object** is an instance of a class. In the `main()` function, objects of type `B` or `D` are created based on user input.

### 2. **Encapsulation** [[Encapsulation]]
   - Both classes use **encapsulation** to hide their internal data members (`i` in `B` and `j` in `D`) and expose them through public methods (`get_i()`).

### 3. **Inheritance** [[Inheritance]]
   - Class `D` **inherits** from class `B`. This means `D` has access to the public and protected members of `B`.
   - Example:
     ```cpp
     class D : public B { ... };
     ```

### 4. **Polymorphism** [[Polymorphism]]
   - The `get_i()` method in `B` is marked as `virtual`, allowing **runtime polymorphism**. This means the derived class (`D`) can override this method.
   - Example:
     ```cpp
     virtual int get_i() { return i; } // In B
     int get_i() { return B::get_i() + j; } // In D
     ```

### 5. **Constructors** [[Constructors]]
   - Both classes have **constructors**:
     - `B()` initializes `i = 1`.
     - `D()` initializes `j = 2` and implicitly calls `B()` to initialize `i`.

### 6. **Scope and Lifetime of Objects** [[Memory Management]]
   - The error occurs because the object `o` is declared inside the `if` or `else` block, making it local to that block. When the program tries to access `o` outside the block, it is out of scope.
   - Example:
     ```cpp
     if (i % 3) {
         D o; // o is local to this block
     }
     else {
         B o; // o is local to this block
     }
     cout << o.get_i(); // ERROR: o is out of scope
     ```

---

## Key Concepts Used 🔑

1. **Class and Object Concepts** [[Class and Object concepts]]: The code defines classes and creates objects.
2. **Encapsulation** [[Encapsulation]]: Data members are private, and methods are public.
3. **Inheritance** [[Inheritance]]: `D` inherits from `B`.
4. **Polymorphism** [[Polymorphism]]: `get_i()` is overridden in `D`.
5. **Constructors** [[Constructors]]: Used to initialize objects.
6. **Scope and Lifetime of Objects** [[Memory Management]]: Objects declared inside blocks are local to those blocks.

---

## Fixing the Code 🛠️

To fix the compilation error, declare `o` outside the `if-else` block and use a pointer or reference to achieve polymorphism:

```cpp
int main() {
    const int i = cin.get();
    B* o; // Declare a pointer to B
    if (i % 3) {
        o = new D(); // Dynamically allocate a D object
    }
    else {
        o = new B(); // Dynamically allocate a B object
    }
    cout << o->get_i(); // Use -> to access members via pointer
    delete o; // Free memory
    return 0;
}
```

---

## Simpler Example for Polymorphism 🐾

Here’s a simpler example to explain **polymorphism**:

```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    virtual void speak() { cout << "Animal sound\n"; }
};

class Dog : public Animal {
public:
    void speak() override { cout << "Woof!\n"; }
};

int main() {
    Animal* a = new Dog();
    a->speak(); // Output: Woof! (Polymorphism in action)
    delete a;
    return 0;
}
```

In this example:
- `Animal` is the base class with a `virtual` method `speak()`.
- `Dog` overrides `speak()`.
- At runtime, the correct method (`Dog::speak()`) is called based on the actual object type.

---

## Summary 📝

- The code demonstrates [[Class and Object concepts]], [[Encapsulation]], [[Inheritance]], and [[Polymorphism]].
- The error occurs due to the **scope** of the object `o` [[Memory Management]].
- Fixing the code requires understanding of **pointers** and **dynamic memory allocation** [[Memory Management]].
- Polymorphism is a powerful feature that allows derived classes to override base class methods [[Polymorphism]].

Let me know if you need further clarification! 😊